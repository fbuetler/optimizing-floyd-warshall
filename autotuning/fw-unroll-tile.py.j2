#include "sp.h"

int floydWarshall(float *C, int N) {
    if (N % {{ blocksize_i }} != 0 || N % {{ blocksize_j }} != 0) {
        return 1;
    }

    for (int k = 0; k < N; k++) {
        for (int ii = 0; ii < N; ii += {{ blocksize_i }}) {
            for (int jj = 0; jj < N; jj += {{ blocksize_j }}) {
                // tile
                int i = ii;
                for (; i - ii < {{ blocksize_i }} - {{ unroll_i - 1 }}; i += {{ unroll_i }}) {
                    {% for u_i in range(unroll_i) -%}
                    {{ "float ci{}k = C[(i + {}) * N + k];".format(u_i, u_i) }}
                    {% endfor -%}

                    int j = jj;
                    for (; j - jj < {{ blocksize_j }} - {{ unroll_j - 1 }}; j += {{ unroll_j }}) {
                        // load
                        {% for u_i in range(unroll_i) -%}
                        {% for u_j in range(unroll_j) -%}
                        {{ "float ci{}j{} = C[(i + {}) * N + j + {}];".format(u_i, u_j, u_i, u_j) }}
                        {% endfor -%}
                        {% endfor %}

                        {% for u_j in range(unroll_j) -%}
                        {{ "float ckj{} = C[k * N + j + {}];".format(u_j, u_j) }}
                        {% endfor %}

                        // compute
                        {% for u_i in range(unroll_i) -%}
                        {% for u_j in range(unroll_j) -%}
                        {{ "float res{}_{} = MIN(ci{}j{}, ci{}k + ckj{});".format(u_i, u_j, u_i, u_j, u_i, u_j) }}
                        {% endfor -%}
                        {% endfor %}

                        // store
                        {% for u_i in range(unroll_i) -%}
                        {% for u_j in range(unroll_j) -%}
                        {{ "C[(i + {}) * N + j + {}] = res{}_{};".format(u_i, u_j, u_i, u_j) }}
                        {% endfor -%}
                        {% endfor %}
                    }

                    // rest of j
                    for (; j < {{ blocksize_j }}; j++) {
                        {% for u_i in range(unroll_i) -%}
                        {{ "C[(i + {}) * N + j] = MIN(C[(i + {}) * N + j], ci{}k + C[k * N + j]);".format(u_i, u_i, u_i) }}
                        {% endfor -%}
                    }
                }

                // rest of i
                for (; i < {{ blocksize_i }}; i++) {
                    float cik = C[i * N + k];
            
                    int j = jj;
                    for (; j < {{ blocksize_j }} - {{ unroll_j - 1 }}; j += {{ unroll_j }}) {
                        // load
                        {% for u_j in range(unroll_j) -%}
                        {{ "float cij{} = C[i * N + j + {}];".format(u_j, u_j) }}
                        {% endfor %}

                        {% for u_j in range(unroll_j) -%}
                        {{ "float ckj{} = C[k * N + j + {}];".format(u_j, u_j) }}
                        {% endfor %}

                        // compute
                        {% for u_j in range(unroll_j) -%}
                        {{ "float res{} = MIN(cij{}, cik + ckj{});".format(u_j,u_j,u_j) }}
                        {% endfor %}

                        // store
                        {% for u_j in range(unroll_j) -%}
                        {{ "C[i * N + j + {}] = res{};".format(u_j, u_j) }}
                        {% endfor %}
                    }

                    // rest of j
                    for (; j < {{ blocksize_j }}; j++) {
                        C[i * N + j] = MIN(C[i * N + j], cik + C[k * N + j]);
                    }
                }
            }
        }
    }
    return 0;
}
